<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursion on Brey Laude</title><link>https://breylaude.com/tags/recursion/</link><description>Recent content in Recursion on Brey Laude</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 21 May 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://breylaude.com/tags/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>Recursive lambdas</title><link>https://breylaude.com/blog/2018-05-21-recursive-lambdas/</link><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><guid>https://breylaude.com/blog/2018-05-21-recursive-lambdas/</guid><description>&lt;p>One can assign a lambda to auto or to &lt;code>std::function&lt;/code>. Normally one would assign a lambda to auto to avoid possible unwanted allocation from &lt;code>std::function&lt;/code>. But if you want recursion, you need to be able to refer to the lambda variable inside the lambda, and you can’t do that if it’s assigned to auto. So how do you do recursive lambdas without using &lt;code>std::function&lt;/code>?&lt;/p>
&lt;p>Use a fixed-point combinator (y-combinator) of course.&lt;/p></description></item></channel></rss>